\chapter{Aplikacja webowa z użyciem WebRTC}

W poniższym rozdziale zostanie omówiona aplikacja webowa wykorzystująca WebRTC.

\begin{figure}[htbp]
  \centering
  \includegraphics[width=\textwidth]{img/webrtc-app}
  \caption{Zrzut ekranu aplikacji WebRTC podczas połączenia na tym samym komputerze}
  \label{fig:webrtc_app}
\end{figure}

Aby nawiązać połączenie, trzeba wykonać następujące kroki:

\begin{enumerate}
  \item Użytkownicy 1 i 2 wciskają przycisk \textbf{Start webcam} aby udostępnić obraz z kamery aplikacji.
  \item Użytkownik 1 wciska przycisk \textbf{Call}, tworząc nowe połączenie.
  \item Użytkownik 1 odczytuje ID połączenia które pojawiło się w polu tekstowym i przekazuje je użytkownikowi 2.
  \item Użytkownik 2 wprowadza ID połączenia uzyskane od użytkownika 1 w to samo pole tekstowe i wciska przycisk
        \textbf{Connect}.
\end{enumerate}

Następnie odbywa się proces nawiązywania połączenia zaprezentowany na diagramie \ref{fig:webrtc_connection_init}.

\begin{figure}[H]
  \centering
  \includegraphics{img/webrtc-connection-init}
  \caption{Diagram prezentujący proces nawiązywania połączenia}
  \label{fig:webrtc_connection_init}
\end{figure}

\begin{enumerate}
  \item Użytkownik 1 tworzy ofertę połączenia oraz wysyła ją do bazy Firestore. Rozpoczyna także proces nasłuchiwania
        odpowiedzi i kandydatów ICE drugiej strony.
  \item Użytkownik 1 rozpoczyna proces odkrywania kandydatów ICE.
  \item Użytkownik 1 wysyła na bieżąco do Firestore otrzymywanych kandydatów ICE (trickle ICE).
  \item Użytkownik 2 odczytuje z bazy ofertę użytkownika 1, generuje na nią odpowiedź, i wysyła ją do Firestore.
  \item Użytkownik 2 rozpoczyna proces odkrywania kandydatów ICE.
  \item Użytkownik 2 wysyła na bieżąco do Firestore otrzymywanych kandydatów ICE (trickle ICE).
  \item Świadomi oferty, odpowiedzi, oraz kandydatów ICE drugiej strony, użytkownicy mogą nawiązać połączenie
        peer-to-peer (lub w sytuacjach kiedy połączenie peer-to-peer jest niemożliwe, łączą się używając serwera TURN
        jako pośrednika).
        
\end{enumerate}

\section{Architektura}

Aplikacja składa się z następujących technologii:

\begin{itemize}
  \item \textbf{Frontend}: Node.js jako środowisko, Vite jako transpilator JS, Typescript jako język programowania
  \item \textbf{Backend}: Firestore z platformy Google Firebase jako pośrednik między klientami w procesie nawiązywania
        połączenia. Firestore jest przede wszystkim bazą danych NoSQL, jednak oferowana przez nią funkcjonalność
        nasłuchiwania dokumentów oraz otrzymywania ich aktualizacji w czasie rzeczywistym sprawia, że może być
        zastosowana w tym celu, co zwalnia programistę z obowiązku przygotowania, utrzymywania i zarządzania serwerem.
  \item \textbf{WebRTC}: Do nawiązywania połączeń wykorzystywane jest API WebRTC dostępne w przeglądarkach
        internetowych. Do realizacji procesu ICE, pozwalającemu stronom na zebranie możliwych ścieżek połączenia
        peer-to-peer, a także w wypadku jego niepowodzenia skorzystanie z serwera TURN jako pośrednika, skorzystano z
        serwerów oferowanych przez \href{https://www.metered.ca/tools/openrelay/}{Open Relay}
\end{itemize}

\section{Wybrane fragmenty kodu}
\subsection{Przechwytywanie wideo i audio}

\begin{lstlisting}[language=Javascript,label=list:media-capture, caption=Przechwytywanie wideo i audio z komputera,
basicstyle=\footnotesize \ttfamily, showtabs=true, tabsize=4]
let localStream: MediaStream;
const webcamButton = document.getElementById('webcamButton');

webcamButton?.addEventListener('click', async () => {
	if (localVideo.srcObject) {
		localVideo.srcObject = null;
		return;
	}

	localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true, });
	webcamButton.innerHTML = 'Stop webcam';

	remoteStream = new MediaStream();
	remoteVideo.srcObject = remoteStream;


	localStream.getTracks().forEach((track) => { peerConnection.addTrack(track, localStream); });
	peerConnection.addEventListener('track', event => {
		event.streams[0].getTracks().forEach(track => {
			remoteStream.addTrack(track);
		});
	});

	localVideo.srcObject = localStream;
	remoteVideo.srcObject = remoteStream;

	callButton.disabled = false;
	answerButton.disabled = false;
});

\end{lstlisting}

\subsection{Tworzenie połączenia}

Aby utworzyć połączenie WebRTC, musimy najpierw skomunikować się z drugim klientem przez jakiś inny kanał, aka.
out-of-band, wykorzystamy do tego celu bazę danych czasu rzeczywistego Firebase. Przygotujemy zatem uchwyt do bazy
danych:

\begin{lstlisting}[language=Javascript,label=list:firebase-init, caption=Inicjalizacja Firebase,
basicstyle=\footnotesize \ttfamily, showtabs=true, tabsize=4]
import { initializeApp } from "firebase/app";
import { getFirestore, collection, addDoc, getDoc, doc, setDoc, onSnapshot, updateDoc } from "firebase/firestore";


// Your web app's Firebase configuration
const firebaseConfig = {
	apiKey: "AIzaSyCr12-OQV5bgdQPFoexd44O9Ubmht966pw",
	authDomain: "piperchat-2eacd.firebaseapp.com",
	projectId: "piperchat-2eacd",
	storageBucket: "piperchat-2eacd.appspot.com",
	messagingSenderId: "172730710087",
	appId: "1:172730710087:web:3dabdb9a62bee44e095962"
};

// Initialize Firebase
const app = initializeApp(firebaseConfig);
const db = getFirestore(app);
\end{lstlisting}

Następnie, do przycisku \textbf{Call} tworzącego połączenie podpinamy handler:

\begin{lstlisting}[language=Javascript,label=list:call-create, caption=Tworzenie połączenia,
basicstyle=\footnotesize \ttfamily, showtabs=true, tabsize=4]
callButton?.addEventListener('click', async () => {
  const callDoc = doc(collection(db, "calls"));
  const offerCandidates = collection(callDoc, "offerCandidates");
  const answerCandidates = collection(callDoc, "answerCandidates");

  callInput.value = callDoc.id;

  peerConnection.onicecandidate = (event) => {
    if (event.candidate) {
      addDoc(offerCandidates, event.candidate.toJSON());
    }
  }

  const offerDescription = await peerConnection.createOffer();
  await peerConnection.setLocalDescription(offerDescription);

  const offer = {
    sdp: offerDescription.sdp,
    type: offerDescription.type
  };

  await setDoc(callDoc, { offer });

  onSnapshot(callDoc, (snapshot) => {
    const data = snapshot.data();
    if (!peerConnection.currentRemoteDescription && data?.answer) {
      const answerDescription = new RTCSessionDescription(data.answer);
      peerConnection.setRemoteDescription(answerDescription);
    }
  });

  onSnapshot(answerCandidates, (snapshot) => {
    snapshot.docChanges().forEach((change) => {
      if (change.type === "added") {
        const candidate = new RTCIceCandidate(change.doc.data());
        peerConnection.addIceCandidate(candidate);
      }
    })
  })
});
\end{lstlisting}

\subsection{Dołączanie do połączenia}

\begin{lstlisting}[language=Javascript,label=list:call-join, caption=Dołączanie do połączenia połączenia,
basicstyle=\footnotesize \ttfamily, showtabs=true, tabsize=4]
answerButton?.addEventListener("click", async () => {
  const callId = callInput.value;
  const callDoc = doc(db, "calls", callId);
  const answerCandidates = collection(callDoc, "answerCandidates");
  const offerCandidates = collection(callDoc, "offerCandidates");

  peerConnection.onicecandidate = (event) => {
    if (event.candidate) {
      addDoc(answerCandidates, event.candidate.toJSON());
    }
  }

  const callData = (await getDoc(callDoc)).data();
  if (!callData) {
    console.error("Call document no longer exists");
    return;
  }
  const offerDescription = callData.offer;
  await peerConnection.setRemoteDescription(new RTCSessionDescription(offerDescription));

  const answerDescription = await peerConnection.createAnswer();
  await peerConnection.setLocalDescription(answerDescription);

  const answer = {
    type: answerDescription.type,
    sdp: answerDescription.sdp,
  };

  await updateDoc(callDoc, { answer });

  onSnapshot(offerCandidates, (snapshot) => {
    snapshot.docChanges().forEach((change) => {
      if (change.type === "added") {
        const data = change.doc.data();
        peerConnection.addIceCandidate(new RTCIceCandidate(data));
      }
    })
  });
});
\end{lstlisting}

\section{Omówienie działania aplikacji na przykładzie}
\subsection{Śledzenie procesu nawiązywania połączenia}

W poniższym rozdziale zostaną omówione dane wymieniane pomiędzy stronami na rzecz ustanowienia połączenia WebRTC.


Aby ustanowić połączenie peer-to-peer, należy rozwiązać poniższe problemy: \cite{hpbn}

\begin{itemize}
  \item Należy powiadomić drugą stronę że chcemy ustanowić do niej połączenie, aby wiedziała ona żeby rozpocząć
        nasłuchiwanie.
  \item Należy zidentyfikować ścieżki trasowania dla połączenia peer-to-peer i uzgodnić jedną pomiędzy obiema stronami.
  \item Należy wymienić niezbędne informacje o używanych przez peerów parametrach połączenia - jakich protokołów,
        kodeków, ustawień, etc. użyć.
\end{itemize}

\subsubsection{Sygnalizowanie negocjacji sesji}

W aplikacji webowej, użytkownik 1 chacący utworzyć nowe połączenie tworzy dokument w kolekcji calls. ID rozmowy to ID
dokumentu utworzonego w bazie Firestore. Obu użytkowników przeprowadzi początkową wymianę danych pisząc do oraz czytając
z tego dokumentu.

Użytkownik 1 tworzy zatem nowy dokument w bazie:

\begin{lstlisting}[language=Javascript,label=list:call-doc-1, caption=Dokument połączenia po utworzeniu przez użytkownika 1,
basicstyle=\footnotesize \ttfamily, showtabs=true, tabsize=4]
{
	id: "YHARFdJoA4lAd8nRu3Uw",
}
\end{lstlisting}

Następnie użytkownik 1 tworzy ofertę, czyli opis połączenia, pozwalający użytkownikowi 2 na połączenie się:

\begin{lstlisting}[language=Javascript,label=list:call-doc-2, caption=Dokument połączenia po dodaniu opisu sesji w protokole SDP,
basicstyle=\footnotesize \ttfamily, showtabs=true, tabsize=4]
{
	id: "YHARFdJoA4lAd8nRu3Uw",
  offer: "v=0o=mozilla...THIS_IS_SDPARTA-99.0 8615225844821133956 0 IN IP4 0.0.0.0s=-t=0 0a=fingerprint:sha-256 5F:A8:8A:A5:B8:1D:0C:39:21:93:FA:3A:B2:B7:B6:3F:EF:8A:5D:3C:6E:86:2E:A7:0A:D4:F0:E3:58:E0:E2:7B..."
}
\end{lstlisting}

Równocześnie, użytkownik 1 rozpoczyna wyszukiwanie kandydatów ICE (Interactive Connecivity Establishment), czyli
sposobów na umożliwienie drugiej stronie do nawiązania ze sobą połączenia (problem nr 2):

\begin{lstlisting}[language=Javascript,label=list:call-doc-3, caption=Dokument połączenia po dodaniu kandydatów ICE,
basicstyle=\footnotesize \ttfamily, showtabs=true, tabsize=4]
{
	id: "YHARFdJoA4lAd8nRu3Uw",
  offer: "v=0o=mozilla...THIS_IS_SDPARTA-99.0 8615225844821133956 0 IN IP4 0.0.0.0s=-t=0 0a=fingerprint:sha-256 5F:A8:8A:A5:B8:1D:0C:39:21:93:FA:3A:B2:B7:B6:3F:EF:8A:5D:3C:6E:86:2E:A7:0A:D4:F0:E3:58:E0:E2:7B...",
  offerCandidates: [
      {
          "candidate": "",
          "sdpMid": "0",
          "usernameFragment": "0b863d52",
          "sdpMLineIndex": 0
      },
      {
          "sdpMLineIndex": 0,
          "sdpMid": "0",
          "candidate": "candidate:1 2 UDP 1686052862 188.122.20.104 42436 typ srflx raddr 192.168.1.2 rport 42436",
          "usernameFragment": "0b863d52"
      },
      {
          "sdpMid": "1",
          "candidate": "",
          "sdpMLineIndex": 1,
          "usernameFragment": "0b863d52"
      },
      {
          "sdpMLineIndex": 1,
          "sdpMid": "1",
          "candidate": "candidate:1 2 UDP 1686052862 188.122.20.104 44466 typ srflx raddr 192.168.1.2 rport 44466",
          "usernameFragment": "0b863d52"
      },
      ...
  ]

}
\end{lstlisting}

Na koniec, użytkownik 1 wysłuchuje zmian w dokumencie sygnalizujących próbę nawiązania połączenia. Dokładniej,
użytkownik 1 oczekuje na pojawienie się, analogicznie do \verb|offer| i \verb|offerCandidates|, pól \verb|answer| oraz
\verb|answerCandidates|. Zawartość tych pól trafi do obiektu \verb|RTCPeerConnection|, które zajmie się ustanowieniem
połączenia.


\subsection{Analiza pakietów protokołu SDP}

Parametry ustanowionego połączenia są determinowane przez protokół SDP. Zobaczmy zatem pakiet SDP z poprzedniego
podrozdziału:

\begin{lstlisting}[label=list:call-sdp-1, caption=Opis oferty połączenia SDP,
basicstyle=\footnotesize \ttfamily, showtabs=true, tabsize=4]
v=0
o=mozilla...THIS_IS_SDPARTA-99.0 107455341790422027 0 IN IP4 0.0.0.0
s=-
t=0 0
a=fingerprint:sha-256 BB:64:A1:DA:F1:E3:93:63:7A:65:E5:55:EA:FC:E9:1F:B6:43:1D:95:6B:2D:CC:34:3B:67:C9:EB:EE:80:43:3D
a=group:BUNDLE 0 1
a=ice-options:trickle
a=msid-semantic:WMS *
m=audio 9 UDP/TLS/RTP/SAVPF 109 9 0 8 101
c=IN IP4 0.0.0.0
a=sendrecv
a=extmap:1 urn:ietf:params:rtp-hdrext:ssrc-audio-level
a=extmap:2/recvonly urn:ietf:params:rtp-hdrext:csrc-audio-level
a=extmap:3 urn:ietf:params:rtp-hdrext:sdes:mid
a=fmtp:109 maxplaybackrate=48000;stereo=1;useinbandfec=1
a=fmtp:101 0-15
a=ice-pwd:efe34e413f35fb225352e73b89d2fa73
a=ice-ufrag:0b863d52
a=mid:0
a=msid:{89963797-b150-406b-8c17-d3a02e5ab84b} {d20d186b-1018-43b9-805d-a8cd94a4e7af}
a=rtcp-mux
a=rtpmap:109 opus/48000/2
a=rtpmap:9 G722/8000/1
a=rtpmap:0 PCMU/8000
a=rtpmap:8 PCMA/8000
a=rtpmap:101 telephone-event/8000/1
a=setup:actpass
a=ssrc:167358539 cname:{a77c69ce-8bfc-4cf6-ac3c-0db7976f374a}
m=video 9 UDP/TLS/RTP/SAVPF 120 124 121 125 126 127 97 98
c=IN IP4 0.0.0.0
a=sendrecv
a=extmap:3 urn:ietf:params:rtp-hdrext:sdes:mid
a=extmap:4 http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time
a=extmap:5 urn:ietf:params:rtp-hdrext:toffset
a=extmap:6/recvonly http://www.webrtc.org/experiments/rtp-hdrext/playout-delay
a=extmap:7 http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01
a=fmtp:126 profile-level-id=42e01f;level-asymmetry-allowed=1;packetization-mode=1
a=fmtp:97 profile-level-id=42e01f;level-asymmetry-allowed=1
a=fmtp:120 max-fs=12288;max-fr=60
a=fmtp:124 apt=120
a=fmtp:121 max-fs=12288;max-fr=60
a=fmtp:125 apt=121
a=fmtp:127 apt=126
a=fmtp:98 apt=97
a=ice-pwd:efe34e413f35fb225352e73b89d2fa73
a=ice-ufrag:0b863d52
a=mid:1
a=msid:{89963797-b150-406b-8c17-d3a02e5ab84b} {ba24bbd7-24aa-42cd-b1b5-7def80a62239}
a=rtcp-fb:120 nack
a=rtcp-fb:120 nack pli
a=rtcp-fb:120 ccm fir
a=rtcp-fb:120 goog-remb
a=rtcp-fb:120 transport-cc
a=rtcp-fb:121 nack
a=rtcp-fb:121 nack pli
a=rtcp-fb:121 ccm fir
a=rtcp-fb:121 goog-remb
a=rtcp-fb:121 transport-cc
a=rtcp-fb:126 nack
a=rtcp-fb:126 nack pli
a=rtcp-fb:126 ccm fir
a=rtcp-fb:126 goog-remb
a=rtcp-fb:126 transport-cc
a=rtcp-fb:97 nack
a=rtcp-fb:97 nack pli
a=rtcp-fb:97 ccm fir
a=rtcp-fb:97 goog-remb
a=rtcp-fb:97 transport-cc
a=rtcp-mux
a=rtcp-rsize
a=rtpmap:120 VP8/90000
a=rtpmap:124 rtx/90000
a=rtpmap:121 VP9/90000
a=rtpmap:125 rtx/90000
a=rtpmap:126 H264/90000
a=rtpmap:127 rtx/90000
a=rtpmap:97 H264/90000
a=rtpmap:98 rtx/90000
a=setup:actpass
a=ssrc:335903003 cname:{a77c69ce-8bfc-4cf6-ac3c-0db7976f374a}
a=ssrc:1910270587 cname:{a77c69ce-8bfc-4cf6-ac3c-0db7976f374a}
a=ssrc-group:FID 335903003 1910270587
\end{lstlisting}

\cite{rfc8866} SDP opisuje sesję jako kolekjcję pól, z których każde zawiera się w jednej linii. Na przykładzie opisu
sesji z listingu \ref{list:call-sdp-1}, można wyróżnić następujące pola:

\begin{itemize}
  \item \verb|v=0|: wersja numeru protokołu - aktualnie 0 jest jedyną możliwą wersją
  \item \verb|o=<username> <sess-id> <sess-version> <nettype> <addrtype> <unicast-address>|: kolekcja pól o inicjatorze
        sesji
        \begin{itemize}
          \item \verb|username: mozilla THIS_IS_SDPARTA-99.0|, \href{https://stackoverflow.com/a/52583935}{co jest referencją do filmu 300}
          \item \verb|sess-id: 107455341790422027|
          \item \verb|sess-version: 0|
          \item \verb|nettype: IN| - \verb|IN| ma oznaczać internet, inne wartości mogą zostać użyte w przyszłości
          \item \verb|addrtype: IP4|
          \item \verb|unicast-address: 0.0.0.0|
        \end{itemize}
  \item \verb|s=-|: nazwa sesji. Z RFC: \say{ The "s=" line MUST NOT be empty. If a session has no meaningful name, then "s= " or "s=-" (i.e., a single space or dash as the session name) is RECOMMENDED.}\cite{rfc8866}
  \item \verb|t=<start-time> <stop-time>|: czas rozpoczęcia i zakończenia sesji w czasie unixowym. Wartość wynosi 0,
        ponieważ sesja nie jest ograniczona czasowo.
  \item \verb|m=<media> <port> <proto> <fmt> ...| - opis mediów:
        \begin{itemize}
          \item \verb|m=audio 9 UDP/TLS/RTP/ SAVPF 109 9 0 8 101|
          \item \verb|m=video 9 UDP/TLS/RTP/ SAVPF 120 124 121 125 126 127 97 98|
        \end{itemize}
\end{itemize}

Resztę opisu dominują pola \verb|a=|: atrybuty, które są głównym sposobem rozszerzania SDP. Mogą one być używane jako
atrybuty sesji, atrybuty mediów, lub oba. Pozycje tego pola zaczynające się od \verb|rtpmap| zawierają oferowane do
użycia w połączeniu kodeki audio i wideo.
